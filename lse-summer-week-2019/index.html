<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>LSE Summer Week 2019 - Talks</title>
        <link href="/stylesheets/style.css" rel="stylesheet" type="text/css">
        <style>
            p {
                text-align: justify;
                margin-left: 5em;
            }
            span.schedule {
                display: block;
                width: 3em;
                float: left;
                margin: 1em 0;
                padding: 0;
                font-weight: bold;
            }
            h2, h3 { clear: both; }
        </style>
    </head>
    <body>
    <div style="margin: 0 auto; max-width: 900px;">
      <h1>LSE Summer Week - July 6 - July 7 2019</h1>

      <h2>Lieu et plan d'accès</h2>

      <p>Amphith&eacute;&acirc;tre 4, EPITA, 24 rue Pasteur, 94276 Le Kremlin-Bicêtre.</p>

      <p>Transports en commun : métro 7 (station Porte d'Italie), bus
      47/125/131/185/186 (station Roger Salengro-Fontainebleau).</p>

      <div style="text-align: center">
        <img src="/images/plan-conferences.png" alt="Plan d'accès">
      </div>

      
<h2>Saturday 6</h2>


<span class="vevent">
	<h3 id="0" class="summary">Introducing the LSE Week </h3>
	<span class="schedule"><span class="dtstart">13h55</span> <span class="dtend">14h00</span></span>
<p class="description">





</p>
</span>


<span class="vevent">
	<h3 id="1" class="summary">Violating your package manager's privacy  - Mathieu Nativel</h3>
	<span class="schedule"><span class="dtstart">14h00</span> <span class="dtend">14h30</span></span>
<p class="description">
Some package managers uses SSL apparently for privacy reasons, let's see if it's possible to guess the transactions made by the package managers without breaking the encryption !




<a href="https://youtu.be/6-bs0pKct6k">Youtube</a>


</p>
</span>


<span class="vevent">
	<h3 id="2" class="summary">Secure lazy binding in x86_64  - Thibault Vivies</h3>
	<span class="schedule"><span class="dtstart">14h45</span> <span class="dtend">15h15</span></span>
<p class="description">
What's dynamic relocation. Overview ld.so, bind now / lazy binding. A solution for read only lazy binding, kbind syscall.




<a href="https://youtu.be/rQEUomyipgw">Youtube</a>


</p>
</span>


<span class="vevent">
	<h3 id="3" class="summary">Arbitrary tree differencing for code copy detection  - Nicolas Manichon</h3>
	<span class="schedule"><span class="dtstart">15h30</span> <span class="dtend">16h00</span></span>
<p class="description">
Code copy has always been a security problem, with open source projects checking in code from one another, applying modifications and not being able to backport security fixes in a timely manner. I present a project that can perform code copy detection on a large number of files.




<a href="https://youtu.be/kc5P3ep3ViQ">Youtube</a>


</p>
</span>


<span class="vevent">
	<h3 id="4" class="summary">pyvmidbg: a flexible hypervisor-level debugger  - Mathieu Tarral</h3>
	<span class="schedule"><span class="dtstart">16h15</span> <span class="dtend">16h45</span></span>
<p class="description">
Virtual machine introspection is a concept where a host application can rebuild a VM's execution context, via the hardware state provided by hypervisor interfaces. This technology has been leveraged since a couple of years already to build powerful stealth sandboxes for malware analysis.
But what about our debuggers ? In this talk, i will explain why debugging from the hypervisor is powerful and relevant in today's world, as well as showing my research on the topic, a Libvmi based GDB stub in Python, capable of debugging a remote process running on Windows XP, on top of Xen.




<a href="https://youtu.be/2GZa5EO7J8c">Youtube</a>


</p>
</span>


<span class="vevent">
	<h3 id="5" class="summary">Arabic fine-grained dialect identification  - Victor Guichard & Gaël de Francony</h3>
	<span class="schedule"><span class="dtstart">17h00</span> <span class="dtend">17h30</span></span>
<p class="description">
We present two approaches for Arabic Fine-Grained Dialect Identification. The first approach is based on Recurrent Neural Networks (BLSTM, BGRU) using hierarchical classification. The main idea is to separate the classification process for a sentence from a given text in two stages. We start with a higher level of classification (8 classes) and then the finer-grained classification (26 classes). The second approach is given by a voting system based on Naive Bayes and Random Forest. Our system achieves an F1-score of 63.02% on the subtask evaluation dataset.




<a href="https://youtu.be/CcHBtcAdZ1Q">Youtube</a>


</p>
</span>


<span class="vevent">
	<h3 id="6" class="summary">Rump session </h3>
	<span class="schedule"><span class="dtstart">17h45</span> <span class="dtend">18h30</span></span>
<p class="description">





</p>
</span>


<span class="vevent">
	<h3 id="7" class="summary">Apéro </h3>
	<span class="schedule"><span class="dtstart">18h30</span> <span class="dtend">19h00</span></span>
<p class="description">





</p>
</span>


<span class="vevent">
	<h3 id="8" class="summary">Barbecue </h3>
	<span class="schedule"><span class="dtstart">19h00</span> <span class="dtend">20h00</span></span>
<p class="description">





</p>
</span>




<h2>Sunday 7</h2>


<span class="vevent">
	<h3 id="9" class="summary">Accelerate Boolean Constraint Propagation for Boolean Satisfiability Solvers with FPGA  - Maxence Caron--Lasne</h3>
	<span class="schedule"><span class="dtstart">14h00</span> <span class="dtend">14h30</span></span>
<p class="description">
Boolean Satisfiability (or SAT) problem is the problem of finding if a set of Boolean values that satisfies a given Boolean formula exists. SAT, even if it is the first problem proven NP-complete, is used in fields like circuit design and automatic theorem proving.
The algorithm used to solve SAT problems is arborescent but the most time consuming operation used in it, the Boolean Constraint Propagation (BCP), is a good target for hardware acceleration.
Based on the work of John D. Davis, we will explore a BCP co-processor design for FPGA. We will also see some possible techniques to improve this design: Content Addressable Memory (CAM) and caching.




<a href="https://youtu.be/nY796be0exg">Youtube</a>


</p>
</span>


<span class="vevent">
	<h3 id="10" class="summary">slab/vmem: introduction to memory management.  - Pierre Cornet</h3>
	<span class="schedule"><span class="dtstart">14h45</span> <span class="dtend">15h15</span></span>
<p class="description">
This talk presents 2 complementary memory management designs used in kernel memory management: slab allocator and vmem allocator. The slab allocator is based on a cache allocation of objects that remain in constructed state between usages. This proves to be space-efficient and fast. The vmem allocator is a general-purpose resource allocator allowing for arbitrary-size allocation and better large object allocation.




<a href="https://youtu.be/it5MZRpDvns">Youtube</a>


</p>
</span>


<span class="vevent">
	<h3 id="11" class="summary">Twenty years of OpenBSD  - Marc Espie</h3>
	<span class="schedule"><span class="dtstart">15h30</span> <span class="dtend">16h15</span></span>
<p class="description">
Since it's the LSE 20th birthday, I thought of doing a quick overview of what I've done in OpenBSD over the past 20 years, one selected commit per year.
Get ready for a walk through memory lane, back when everything was a.out and 32MB of memory was decent.
<a href=lse-summer-week-2019/slides/lse-summer-week-2019-11-docs.tgz>Docs</a>



<a href="/lse-summer-week-2019/slides/lse-summer-week-2019-11-20ans.pdf">Slides</a>


<a href="https://youtu.be/xHqn8NMTY0o">Youtube</a>


</p>
</span>


<span class="vevent">
	<h3 id="12" class="summary">Reverse engineering through execution trace analysis  - Gabriel Duque & Tanguy Dubroca</h3>
	<span class="schedule"><span class="dtstart">16h30</span> <span class="dtend">17h00</span></span>
<p class="description">
When participating in CTF competitions, one is often presented with crackme exercises consisting of virtual machines. In general, these virtual machines execute little bits of native code for each opcode their input is comprised of. We will see how execution trace capture, binary lifting and optimization can help us simplify the problem by eliminating the virtual machine.



<a href="/lse-summer-week-2019/slides/lse-summer-week-2019-12-re_trace_analysis.pdf">Slides</a>


<a href="https://youtu.be/nKvtXpgh7X8">Youtube</a>


</p>
</span>


<span class="vevent">
	<h3 id="13" class="summary">The return of pledge: rise of the patches  - Guillaume Pagnoux</h3>
	<span class="schedule"><span class="dtstart">17h15</span> <span class="dtend">17h45</span></span>
<p class="description">
Last year, I presented my work on trying to implement pledge in a somewhat mergeable way. Since, it could not work the way I intended, let's try again, without caring about being merged someday. For more context, last year's talk can be found here: https://www.youtube.com/watch?v=uXgxMDglxVM




<a href="https://youtu.be/PK7gETZURx0">Youtube</a>


</p>
</span>







    </div>
    


  <!-- Google Analytics (http://google.com/analytics) -->
  <script>
    !function(j,e,k,y,l,L){j.GoogleAnalyticsObject=y,j[y]||(j[y]=function(){
    (j[y].q=j[y].q||[]).push(arguments)}),j[y].l=+new Date,l=e.createElement(k),
    L=e.getElementsByTagName(k)[0],l.src='//www.google-analytics.com/analytics.js',
    L.parentNode.insertBefore(l,L)}(window,document,'script','ga');

    ga('create', 'UA-50755011-1', 'auto');
    ga('send', 'pageview');

  </script>


    </body>
</html>
